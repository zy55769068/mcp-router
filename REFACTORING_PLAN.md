# MCP Router ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°è¨ˆç”» (2025å¹´ç‰ˆ)

## ğŸ“– ç›®æ¬¡

1. [æ¦‚è¦](#æ¦‚è¦)
2. [å“è³ªè©•ä¾¡çµæœã«åŸºã¥ãç¾çŠ¶åˆ†æ](#å“è³ªè©•ä¾¡çµæœã«åŸºã¥ãç¾çŠ¶åˆ†æ)
3. [å„ªå…ˆåº¦ä»˜ããƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°æˆ¦ç•¥](#å„ªå…ˆåº¦ä»˜ããƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°æˆ¦ç•¥)
4. [Critical Phase: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã¨å“è³ªä¿è¨¼](#critical-phase-ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã¨å“è³ªä¿è¨¼)
5. [Phase 1: ãƒ†ã‚¹ãƒˆåŸºç›¤æ§‹ç¯‰](#phase-1-ãƒ†ã‚¹ãƒˆåŸºç›¤æ§‹ç¯‰)
6. [Phase 2: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–](#phase-2-ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–)
7. [Phase 3: ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°æ¨™æº–åŒ–](#phase-3-ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°æ¨™æº–åŒ–)
8. [Phase 4: ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆæœ€é©åŒ–ã¨è¨­å®šæ•´ç†](#phase-4-ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆæœ€é©åŒ–ã¨è¨­å®šæ•´ç†)
9. [æˆåŠŸæŒ‡æ¨™](#æˆåŠŸæŒ‡æ¨™)
10. [ãƒªã‚¹ã‚¯ç®¡ç†](#ãƒªã‚¹ã‚¯ç®¡ç†)

## æ¦‚è¦

**ã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹å“è³ªè©•ä¾¡çµæœ: 7.5/10**

MCP Router ã¯ Model Context Protocol ã‚µãƒ¼ãƒãƒ¼ã‚’ç®¡ç†ã™ã‚‹Electronã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã™ã€‚åŒ…æ‹¬çš„ãªå“è³ªè©•ä¾¡ã®çµæœã€æ—¢å­˜ã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã¯äºˆæƒ³ä»¥ä¸Šã«è‰¯å¥½ãªçŠ¶æ…‹ã§ã™ãŒã€**è‡´å‘½çš„ãªèª²é¡Œ**ãŒç‰¹å®šã•ã‚Œã¾ã—ãŸã€‚

### ğŸš¨ **Critical Issues (å³åº§ã«å¯¾å¿œãŒå¿…è¦)**

1. **ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸: 0%** - å˜ä½“ãƒ»çµ±åˆãƒ»E2Eãƒ†ã‚¹ãƒˆãŒå­˜åœ¨ã—ãªã„
2. **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è„†å¼±æ€§** - å…¥åŠ›æ¤œè¨¼ä¸è¶³ã€IPCãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ¤œè¨¼ãªã—
3. **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä¸çµ±ä¸€** - æ§‹é€ åŒ–ã•ã‚ŒãŸãƒ­ã‚°è¨˜éŒ²ä¸è¶³

### ğŸ¯ **æ›´æ–°ã•ã‚ŒãŸãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ç›®æ¨™**

1. **å“è³ªä¿è¨¼ã®ç¢ºç«‹**: åŒ…æ‹¬çš„ãªãƒ†ã‚¹ãƒˆæˆ¦ç•¥ã®å®Ÿè£…
2. **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–**: å…¥åŠ›æ¤œè¨¼ã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»ã®å®Ÿæ–½
3. **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°æ¨™æº–åŒ–**: çµ±ä¸€ã•ã‚ŒãŸã‚¨ãƒ©ãƒ¼å‡¦ç†ã‚·ã‚¹ãƒ†ãƒ 
4. **ä¿å®ˆæ€§å‘ä¸Š**: è¨­å®šå€¤ä¸€å…ƒåŒ–ã¨ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆæœ€é©åŒ–

## å“è³ªè©•ä¾¡çµæœã«åŸºã¥ãç¾çŠ¶åˆ†æ

### âœ… **å„ªç§€ãªå®Ÿè£…é ˜åŸŸ (8/10 ä»¥ä¸Š)**

| é ˜åŸŸ | è©•ä¾¡ | çŠ¶æ³ |
|------|------|------|
| **ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ** | 8/10 | ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆ†é›¢ã¨ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ§‹é€ ãŒè‰¯å¥½ |
| **TypeScriptæ´»ç”¨** | 8.5/10 | å‹å®‰å…¨æ€§ãŒé«˜ãã€é©åˆ‡ãªã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹è¨­è¨ˆ |
| **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆ** | 8/10 | Repository ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ ã‚·ã‚¹ãƒ†ãƒ  |
| **IPCé€šä¿¡ãƒ‘ã‚¿ãƒ¼ãƒ³** | 8/10 | ä¸€è²«ã—ãŸã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¨å‘½åè¦å‰‡ |
| **UI/UXã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£** | 7.5/10 | Radix UI + Tailwindã€ZustandçŠ¶æ…‹ç®¡ç† |

### ğŸ”´ **Critical Issues (å³åº§ã«å¯¾å¿œãŒå¿…è¦)**

| èª²é¡Œ | è©•ä¾¡ | ç¾åœ¨ã®çŠ¶æ³ | å½±éŸ¿åº¦ |
|------|------|------------|--------|
| **ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸** | 2/10 | å˜ä½“ãƒ»çµ±åˆãƒ»E2Eãƒ†ã‚¹ãƒˆãŒå­˜åœ¨ã—ãªã„ | ğŸ”´ High |
| **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£** | 7/10 | å…¥åŠ›æ¤œè¨¼ä¸è¶³ã€IPCãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ¤œè¨¼ãªã— | ğŸ”´ High |
| **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°** | 6/10 | ä¸€è²«æ€§ã«æ¬ ã‘ã€æ§‹é€ åŒ–ãƒ­ã‚°ä¸è¶³ | ğŸŸ¡ Medium |

### ğŸŸ¡ **æ”¹å–„ãŒå¿…è¦ãªé ˜åŸŸ**

| ãƒ•ã‚¡ã‚¤ãƒ«/é ˜åŸŸ | è¡Œæ•° | ç¾åœ¨ã®å•é¡Œ | å„ªå…ˆåº¦ |
|-------------|------|-----------|--------|
| `src/main.ts` | 966è¡Œ | è¨­å®šå€¤æ•£åœ¨ã€IPCãƒãƒ³ãƒ‰ãƒ©ãƒ¼é›†ä¸­ | ğŸŸ¡ Medium |
| `src/components/Home.tsx` | 307è¡Œ | UIãƒ»æ¤œç´¢ãƒ»ç®¡ç†ãƒ­ã‚¸ãƒƒã‚¯æ··åœ¨ | ğŸŸ¡ Medium |
| ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ | - | 2ç§’ãƒãƒ¼ãƒªãƒ³ã‚°ã€ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯æ‡¸å¿µ | ğŸŸ¡ Medium |

## å„ªå…ˆåº¦ä»˜ããƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°æˆ¦ç•¥

### ğŸ¯ **Critical Path (å“è³ªè©•ä¾¡ã«åŸºã¥ãå„ªå…ˆé †ä½)**

| ãƒ•ã‚§ãƒ¼ã‚º | é‡è¦åº¦ | æœŸé–“ | åŠ¹æœ | ç¾åœ¨ã®è©•ä¾¡ |
|---------|--------|------|------|----------|
| Critical: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ»å“è³ªä¿è¨¼ | ğŸ”´ Critical | 1é€±é–“ | æœ¬ç•ªç’°å¢ƒå¯¾å¿œå¯èƒ½åŒ– | ç·Šæ€¥å¯¾å¿œå¿…é ˆ |
| Phase 1: ãƒ†ã‚¹ãƒˆåŸºç›¤æ§‹ç¯‰ | ğŸ”´ High | 2é€±é–“ | å“è³ªä¿è¨¼ãƒ»ç¶™ç¶šé–‹ç™ºåŸºç›¤ | æœ€é‡è¦èª²é¡Œ |
| Phase 2: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ– | ğŸ”´ High | 1é€±é–“ | ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è„†å¼±æ€§è§£æ¶ˆ | é‡è¦èª²é¡Œ |
| Phase 3: ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°æ¨™æº–åŒ– | ğŸŸ¡ Medium | 1é€±é–“ | ä¿å®ˆæ€§ãƒ»ãƒ‡ãƒãƒƒã‚°æ€§å‘ä¸Š | æ¨™æº–åŒ–èª²é¡Œ |
| Phase 4: ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆæœ€é©åŒ– | ğŸŸ¡ Medium | 2é€±é–“ | é–‹ç™ºåŠ¹ç‡ãƒ»ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£ | æ¼¸é€²çš„æ”¹å–„ |

## Critical Phase: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã¨å“è³ªä¿è¨¼

### ğŸš¨ **ç·Šæ€¥å¯¾å¿œé …ç›® (æœ€å„ªå…ˆ)**

#### 1. å…¥åŠ›æ¤œè¨¼ã®å®Ÿè£…

**`src/lib/validation/input-validator.ts`**
```typescript
import { z } from 'zod';

// MCPã‚µãƒ¼ãƒãƒ¼è¨­å®šã®æ¤œè¨¼ã‚¹ã‚­ãƒ¼ãƒ
export const MCPServerConfigSchema = z.object({
  name: z.string().min(1, 'Server name is required').max(100, 'Server name too long'),
  description: z.string().optional(),
  serverType: z.enum(['local', 'remote', 'remote-streamable']),
  command: z.string().min(1).optional(),
  args: z.array(z.string()).optional(),
  env: z.record(z.string()).optional(),
  url: z.string().url().optional(),
});

// ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆè¨­å®šã®æ¤œè¨¼ã‚¹ã‚­ãƒ¼ãƒ
export const AgentConfigSchema = z.object({
  name: z.string().min(1, 'Agent name is required').max(100, 'Agent name too long'),
  description: z.string().optional(),
  model: z.string().min(1, 'Model is required'),
  tools: z.array(z.string()).optional(),
  systemPrompt: z.string().optional(),
});

// IPCãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ¤œè¨¼
export function validateIpcParams<T>(schema: z.ZodSchema<T>, data: unknown): T {
  try {
    return schema.parse(data);
  } catch (error) {
    if (error instanceof z.ZodError) {
      throw new Error(`Validation failed: ${error.errors.map(e => e.message).join(', ')}`);
    }
    throw new Error('Invalid input data');
  }
}
```

**`src/main/utils/ipc-validator.ts`**
```typescript
import { ipcMain, IpcMainInvokeEvent } from 'electron';
import { z } from 'zod';
import { validateIpcParams } from '../../lib/validation/input-validator';

// å®‰å…¨ãªIPCãƒãƒ³ãƒ‰ãƒ©ãƒ¼ãƒ©ãƒƒãƒ‘ãƒ¼
export function createSecureIpcHandler<TInput, TOutput>(
  channel: string,
  schema: z.ZodSchema<TInput>,
  handler: (event: IpcMainInvokeEvent, validatedInput: TInput) => Promise<TOutput>
) {
  return ipcMain.handle(channel, async (event, ...args) => {
    try {
      // å…¥åŠ›æ¤œè¨¼
      const validatedInput = validateIpcParams(schema, args[0]);
      
      // ãƒãƒ³ãƒ‰ãƒ©ãƒ¼å®Ÿè¡Œ
      return await handler(event, validatedInput);
    } catch (error) {
      console.error(`IPC Error [${channel}]:`, error);
      throw error;
    }
  });
}

// ä½¿ç”¨ä¾‹
createSecureIpcHandler(
  'mcp:add',
  MCPServerConfigSchema,
  async (event, serverConfig) => {
    // æ¤œè¨¼æ¸ˆã¿ã®serverConfigã‚’ä½¿ç”¨
    return mcpServerManager.addServer(serverConfig);
  }
);
```

#### 2. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»ã®å®Ÿè£…

**`src/lib/security/security-audit.ts`**
```typescript
import crypto from 'crypto';

export class SecurityAudit {
  private static readonly SENSITIVE_PATTERNS = [
    /api[_-]?key/i,
    /secret/i,
    /token/i,
    /password/i,
    /private[_-]?key/i,
  ];

  static sanitizeForLogging(data: any): any {
    if (typeof data !== 'object' || data === null) {
      return data;
    }

    const sanitized = { ...data };
    
    for (const [key, value] of Object.entries(sanitized)) {
      if (this.isSensitiveField(key)) {
        sanitized[key] = this.maskSensitiveValue(value);
      } else if (typeof value === 'object') {
        sanitized[key] = this.sanitizeForLogging(value);
      }
    }

    return sanitized;
  }

  private static isSensitiveField(fieldName: string): boolean {
    return this.SENSITIVE_PATTERNS.some(pattern => pattern.test(fieldName));
  }

  private static maskSensitiveValue(value: any): string {
    if (typeof value !== 'string') {
      return '[REDACTED]';
    }
    if (value.length <= 4) {
      return '*'.repeat(value.length);
    }
    return value.substring(0, 2) + '*'.repeat(value.length - 4) + value.substring(value.length - 2);
  }
}
```

#### 3. æ§‹é€ åŒ–ãƒ­ã‚°ã‚·ã‚¹ãƒ†ãƒ 

**`src/lib/logging/structured-logger.ts`**
```typescript
import winston from 'winston';
import { SecurityAudit } from '../security/security-audit';

interface LogContext {
  userId?: string;
  sessionId?: string;
  operation?: string;
  component?: string;
  timestamp?: Date;
}

export class StructuredLogger {
  private logger: winston.Logger;

  constructor() {
    this.logger = winston.createLogger({
      level: process.env.NODE_ENV === 'development' ? 'debug' : 'info',
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.errors({ stack: true }),
        winston.format.json(),
        winston.format.printf(({ timestamp, level, message, ...meta }) => {
          return JSON.stringify({
            timestamp,
            level,
            message,
            ...SecurityAudit.sanitizeForLogging(meta)
          });
        })
      ),
      transports: [
        new winston.transports.File({ 
          filename: 'logs/error.log', 
          level: 'error',
          maxsize: 10 * 1024 * 1024, // 10MB
          maxFiles: 5
        }),
        new winston.transports.File({ 
          filename: 'logs/combined.log',
          maxsize: 10 * 1024 * 1024, // 10MB
          maxFiles: 5
        }),
        new winston.transports.Console({
          format: winston.format.combine(
            winston.format.colorize(),
            winston.format.simple()
          )
        })
      ]
    });
  }

  info(message: string, context?: LogContext) {
    this.logger.info(message, context);
  }

  error(message: string, error?: Error, context?: LogContext) {
    this.logger.error(message, { 
      error: error?.message,
      stack: error?.stack,
      ...context 
    });
  }

  warn(message: string, context?: LogContext) {
    this.logger.warn(message, context);
  }

  debug(message: string, context?: LogContext) {
    this.logger.debug(message, context);
  }
}

export const logger = new StructuredLogger();
```

## Phase 1: ãƒ†ã‚¹ãƒˆåŸºç›¤æ§‹ç¯‰

### ğŸ¯ ç›®æ¨™
å“è³ªä¿è¨¼ã®ç¢ºç«‹ã¨ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸80%ä»¥ä¸Šã®é”æˆ

#### 1.1 ãƒ†ã‚¹ãƒˆç’°å¢ƒã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

**`package.json` ãƒ†ã‚¹ãƒˆé–¢é€£ã®è¿½åŠ **
```json
{
  "devDependencies": {
    "vitest": "^1.0.0",
    "@testing-library/react": "^14.0.0",
    "@testing-library/jest-dom": "^6.0.0",
    "@testing-library/user-event": "^14.0.0",
    "happy-dom": "^12.0.0",
    "msw": "^2.0.0",
    "@vitest/coverage-v8": "^1.0.0",
    "@vitest/ui": "^1.0.0"
  },
  "scripts": {
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage",
    "test:watch": "vitest --watch",
    "test:integration": "vitest run --config vitest.integration.config.ts"
  }
}
```

**`vitest.config.ts`**
```typescript
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'happy-dom',
    setupFiles: ['./src/test/setup.ts'],
    globals: true,
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      thresholds: {
        global: {
          branches: 80,
          functions: 80,
          lines: 80,
          statements: 80
        }
      },
      exclude: [
        'node_modules/',
        'src/test/',
        '**/*.test.{ts,tsx}',
        '**/*.config.{ts,js}',
        'src/main.ts' // Electronãƒ¡ã‚¤ãƒ³ãƒ—ãƒ­ã‚»ã‚¹ã¯é™¤å¤–
      ]
    }
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src')
    }
  }
});
```

#### 1.2 ãƒ¢ãƒƒã‚¯ã‚µãƒ¼ãƒ“ã‚¹ã¨ãƒ†ã‚¹ãƒˆãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£

**`src/test/mocks/electron-api.ts`**
```typescript
import { vi } from 'vitest';

export const mockElectronAPI = {
  // MCP Server API
  listMcpServers: vi.fn(),
  startMcpServer: vi.fn(),
  stopMcpServer: vi.fn(),
  addMcpServer: vi.fn(),
  removeMcpServer: vi.fn(),
  
  // Agent API
  listAgents: vi.fn(),
  createAgent: vi.fn(),
  updateAgent: vi.fn(),
  deleteAgent: vi.fn(),
  
  // Auth API
  login: vi.fn(),
  logout: vi.fn(),
  getAuthStatus: vi.fn(),
};

// ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ¢ãƒƒã‚¯è¨­å®š
Object.defineProperty(window, 'electronAPI', {
  value: mockElectronAPI,
  writable: true
});
```

**`src/test/utils/test-utils.tsx`**
```typescript
import React from 'react';
import { render, RenderOptions } from '@testing-library/react';
import { HashRouter } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

// ãƒ†ã‚¹ãƒˆç”¨ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼
const TestProviders = ({ children }: { children: React.ReactNode }) => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false }
    }
  });

  return (
    <QueryClientProvider client={queryClient}>
      <HashRouter>
        {children}
      </HashRouter>
    </QueryClientProvider>
  );
};

// ã‚«ã‚¹ã‚¿ãƒ ãƒ¬ãƒ³ãƒ€ãƒ¼é–¢æ•°
export const renderWithProviders = (
  ui: React.ReactElement,
  options?: Omit<RenderOptions, 'wrapper'>
) => {
  return render(ui, { wrapper: TestProviders, ...options });
};

// ã‚ˆãä½¿ç”¨ã™ã‚‹ãƒãƒƒãƒãƒ£ãƒ¼
export * from '@testing-library/react';
export { renderWithProviders as render };
```

#### 1.3 ã‚µãƒ¼ãƒ“ã‚¹å±¤ã®å˜ä½“ãƒ†ã‚¹ãƒˆ

**`src/lib/services/__tests__/server-service.test.ts`**
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { ServerService } from '../server-service';
import { mockElectronAPI } from '../../../test/mocks/electron-api';

describe('ServerService', () => {
  let serverService: ServerService;

  beforeEach(() => {
    vi.clearAllMocks();
    serverService = ServerService.getInstance();
  });

  describe('getAll', () => {
    it('should return list of servers', async () => {
      const mockServers = [
        { id: '1', name: 'Test Server 1', status: 'stopped' },
        { id: '2', name: 'Test Server 2', status: 'running' }
      ];
      
      mockElectronAPI.listMcpServers.mockResolvedValue(mockServers);

      const result = await serverService.getAll();

      expect(result).toEqual(mockServers);
      expect(mockElectronAPI.listMcpServers).toHaveBeenCalledOnce();
    });

    it('should handle errors gracefully', async () => {
      const error = new Error('Database connection failed');
      mockElectronAPI.listMcpServers.mockRejectedValue(error);

      await expect(serverService.getAll()).rejects.toThrow('Database connection failed');
    });
  });

  describe('startServer', () => {
    it('should start server successfully', async () => {
      mockElectronAPI.startMcpServer.mockResolvedValue(true);

      const result = await serverService.startServer('test-id');

      expect(result).toBe(true);
      expect(mockElectronAPI.startMcpServer).toHaveBeenCalledWith('test-id');
    });
  });
});
```

#### 1.4 Reactã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ãƒ†ã‚¹ãƒˆ

**`src/components/__tests__/Home.test.tsx`**
```typescript
import { describe, it, expect, vi } from 'vitest';
import { screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { render } from '../../test/utils/test-utils';
import { Home } from '../Home';
import { mockElectronAPI } from '../../test/mocks/electron-api';

describe('Home Component', () => {
  it('should display list of servers', async () => {
    const mockServers = [
      { id: '1', name: 'Test Server 1', status: 'stopped' },
      { id: '2', name: 'Test Server 2', status: 'running' }
    ];
    
    mockElectronAPI.listMcpServers.mockResolvedValue(mockServers);

    render(<Home />);

    await waitFor(() => {
      expect(screen.getByText('Test Server 1')).toBeInTheDocument();
      expect(screen.getByText('Test Server 2')).toBeInTheDocument();
    });
  });

  it('should filter servers by search term', async () => {
    const mockServers = [
      { id: '1', name: 'Alpha Server', status: 'stopped' },
      { id: '2', name: 'Beta Server', status: 'running' }
    ];
    
    mockElectronAPI.listMcpServers.mockResolvedValue(mockServers);

    const user = userEvent.setup();
    render(<Home />);

    await waitFor(() => {
      expect(screen.getByText('Alpha Server')).toBeInTheDocument();
    });

    const searchInput = screen.getByPlaceholderText(/search/i);
    await user.type(searchInput, 'Alpha');

    await waitFor(() => {
      expect(screen.getByText('Alpha Server')).toBeInTheDocument();
      expect(screen.queryByText('Beta Server')).not.toBeInTheDocument();
    });
  });
});
```

## Phase 2: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–

### ğŸ¯ ç›®æ¨™
ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è„†å¼±æ€§ã®è§£æ¶ˆã¨å®‰å…¨ãªé‹ç”¨ç’°å¢ƒã®ç¢ºç«‹

#### 2.1 CSP (Content Security Policy) ã®å¼·åŒ–

**`src/main/security/csp-config.ts`**
```typescript
export const CSP_POLICIES = {
  development: [
    "default-src 'self' 'unsafe-inline' http://localhost:* ws://localhost:*",
    "script-src 'self' 'unsafe-eval' 'unsafe-inline'",
    "connect-src 'self' http://localhost:* ws://localhost:* https://mcp-router.net",
    "img-src 'self' data:",
    "style-src 'self' 'unsafe-inline'"
  ].join('; '),
  
  production: [
    "default-src 'self'",
    "script-src 'self'",
    "connect-src 'self' https://mcp-router.net",
    "img-src 'self' data:",
    "style-src 'self' 'unsafe-inline'"
  ].join('; ')
};

export function applyCspPolicy(isDev: boolean): void {
  const { session } = require('electron');
  
  session.defaultSession.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        'Content-Security-Policy': [isDev ? CSP_POLICIES.development : CSP_POLICIES.production],
        'X-Content-Type-Options': ['nosniff'],
        'X-Frame-Options': ['DENY'],
        'X-XSS-Protection': ['1; mode=block']
      }
    });
  });
}
```

#### 2.2 å®‰å…¨ãªIPCãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

**`src/main/security/secure-ipc.ts`**
```typescript
import { ipcMain, IpcMainInvokeEvent } from 'electron';
import { z } from 'zod';
import { logger } from '../../lib/logging/structured-logger';

interface IpcContext {
  userId?: string;
  sessionId?: string;
  timestamp: Date;
}

export class SecureIpcManager {
  private static registeredHandlers = new Set<string>();

  static registerSecureHandler<TInput, TOutput>(
    channel: string,
    schema: z.ZodSchema<TInput>,
    handler: (event: IpcMainInvokeEvent, input: TInput, context: IpcContext) => Promise<TOutput>,
    options: {
      requireAuth?: boolean;
      rateLimit?: { maxCalls: number; windowMs: number };
    } = {}
  ) {
    if (this.registeredHandlers.has(channel)) {
      throw new Error(`Handler for channel ${channel} already registered`);
    }

    this.registeredHandlers.add(channel);

    ipcMain.handle(channel, async (event, ...args) => {
      const context: IpcContext = {
        timestamp: new Date()
      };

      try {
        // ãƒ­ã‚°è¨˜éŒ²
        logger.info(`IPC Request: ${channel}`, {
          component: 'IPC',
          operation: channel,
          ...context
        });

        // èªè¨¼ãƒã‚§ãƒƒã‚¯
        if (options.requireAuth) {
          // èªè¨¼ãƒ­ã‚¸ãƒƒã‚¯ã®å®Ÿè£…
        }

        // ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒã‚§ãƒƒã‚¯
        if (options.rateLimit) {
          // ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒ­ã‚¸ãƒƒã‚¯ã®å®Ÿè£…
        }

        // å…¥åŠ›æ¤œè¨¼
        const validatedInput = schema.parse(args[0]);

        // ãƒãƒ³ãƒ‰ãƒ©ãƒ¼å®Ÿè¡Œ
        const result = await handler(event, validatedInput, context);

        logger.info(`IPC Response: ${channel}`, {
          component: 'IPC',
          operation: channel,
          success: true,
          ...context
        });

        return result;
      } catch (error) {
        logger.error(`IPC Error: ${channel}`, error, {
          component: 'IPC',
          operation: channel,
          ...context
        });

        // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’è€ƒæ…®ã—ãŸã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹
        if (error instanceof z.ZodError) {
          throw new Error('Invalid input parameters');
        }
        
        throw new Error('Operation failed');
      }
    });
  }
}
```

## Phase 3: ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°æ¨™æº–åŒ–

### ğŸ¯ ç›®æ¨™
çµ±ä¸€ã•ã‚ŒãŸã‚¨ãƒ©ãƒ¼å‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ã®ç¢ºç«‹

#### 3.1 çµ±ä¸€ã‚¨ãƒ©ãƒ¼å‹ã®å®šç¾©

**`src/lib/errors/app-errors.ts`**
```typescript
export enum ErrorCode {
  // ä¸€èˆ¬çš„ã‚¨ãƒ©ãƒ¼
  UNKNOWN_ERROR = 'UNKNOWN_ERROR',
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  NETWORK_ERROR = 'NETWORK_ERROR',
  PERMISSION_DENIED = 'PERMISSION_DENIED',
  
  // ã‚µãƒ¼ãƒãƒ¼é–¢é€£
  SERVER_NOT_FOUND = 'SERVER_NOT_FOUND',
  SERVER_START_FAILED = 'SERVER_START_FAILED',
  SERVER_STOP_FAILED = 'SERVER_STOP_FAILED',
  SERVER_CONFIG_INVALID = 'SERVER_CONFIG_INVALID',
  
  // ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé–¢é€£
  AGENT_NOT_FOUND = 'AGENT_NOT_FOUND',
  AGENT_CREATION_FAILED = 'AGENT_CREATION_FAILED',
  AGENT_DEPLOY_FAILED = 'AGENT_DEPLOY_FAILED',
  
  // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹é–¢é€£
  DATABASE_ERROR = 'DATABASE_ERROR',
  TRANSACTION_FAILED = 'TRANSACTION_FAILED',
}

export class AppError extends Error {
  constructor(
    public readonly code: ErrorCode,
    message: string,
    public readonly cause?: Error,
    public readonly context?: Record<string, any>
  ) {
    super(message);
    this.name = 'AppError';
  }

  static create(code: ErrorCode, message: string, cause?: Error, context?: Record<string, any>): AppError {
    return new AppError(code, message, cause, context);
  }

  toJSON() {
    return {
      name: this.name,
      code: this.code,
      message: this.message,
      context: this.context,
      cause: this.cause?.message,
      stack: this.stack
    };
  }
}

export type Result<T, E = AppError> = 
  | { success: true; data: T }
  | { success: false; error: E };
```

#### 3.2 ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£

**`src/lib/errors/error-handler.ts`**
```typescript
import { ErrorCode, AppError, Result } from './app-errors';
import { logger } from '../logging/structured-logger';

export class ErrorHandler {
  static wrap<T>(
    operation: () => Promise<T>,
    errorCode: ErrorCode,
    context?: Record<string, any>
  ): Promise<Result<T>> {
    return operation()
      .then(data => ({ success: true, data } as const))
      .catch(error => {
        const appError = error instanceof AppError 
          ? error
          : AppError.create(errorCode, error.message, error, context);
        
        logger.error(`Operation failed: ${errorCode}`, appError, context);
        
        return { success: false, error: appError } as const;
      });
  }

  static handleApiError(error: unknown, defaultCode = ErrorCode.UNKNOWN_ERROR): AppError {
    if (error instanceof AppError) {
      return error;
    }
    
    if (error instanceof Error) {
      return AppError.create(defaultCode, error.message, error);
    }
    
    return AppError.create(defaultCode, 'An unknown error occurred');
  }

  static async handleAsyncOperation<T>(
    operation: () => Promise<T>,
    errorCode: ErrorCode,
    context?: Record<string, any>
  ): Promise<T> {
    try {
      return await operation();
    } catch (error) {
      const appError = this.handleApiError(error, errorCode);
      if (context) {
        appError.context = { ...appError.context, ...context };
      }
      throw appError;
    }
  }
}
```

## Phase 4: ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆæœ€é©åŒ–ã¨è¨­å®šæ•´ç†

### ğŸ¯ ç›®æ¨™
ä¿å®ˆæ€§ã®å‘ä¸Šã¨é–‹ç™ºåŠ¹ç‡ã®æ”¹å–„

#### 4.1 è¨­å®šå€¤ã®ä¸€å…ƒåŒ–

**`src/config/app-config.ts`**
```typescript
export const APP_CONFIG = {
  // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³åŸºæœ¬è¨­å®š
  APP_NAME: 'MCP Router',
  VERSION: process.env.npm_package_version || '1.0.0',
  
  // URLs
  BASE_URL: process.env.BASE_URL || 'https://mcp-router.net/',
  get API_BASE_URL() { return `${this.BASE_URL}api`; },
  
  // ã‚µãƒ¼ãƒãƒ¼è¨­å®š
  HTTP_SERVER_PORT: parseInt(process.env.HTTP_SERVER_PORT || '3282'),
  
  // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒ»ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«è¨­å®š
  TRAY_UPDATE_INTERVAL: 5000,
  AUTO_UPDATE_INTERVAL: '1 hour',
  STARTUP_TIMEOUT: 10000,
  CONNECTION_RETRY_DELAY: 2000,
  
  // è­˜åˆ¥å­
  AGGREGATOR_SERVER_ID: 'mcp-router-aggregator',
  AGGREGATOR_SERVER_NAME: 'MCP Router Aggregator',
  
  // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
  CONFIG_FILE_NAME: 'mcp-router-config.json',
  LOG_FILE_NAME: 'mcp-router.log',
  
  // é–‹ç™ºç’°å¢ƒè¨­å®š
  IS_DEV: process.env.NODE_ENV === 'development',
  IS_PROD: process.env.NODE_ENV === 'production',
} as const;

export type AppConfig = typeof APP_CONFIG;
```

#### 4.2 Home.tsx ã®æœ€é©åŒ–

**æ–°ã—ã„ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆæ§‹é€ :**
```
src/components/server/
â”œâ”€â”€ ServerList.tsx              # ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒŠ (100è¡Œä»¥ä¸‹)
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ ServerGrid.tsx          # ã‚µãƒ¼ãƒãƒ¼ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤º
â”‚   â”œâ”€â”€ ServerCard.tsx          # å€‹åˆ¥ã‚µãƒ¼ãƒãƒ¼ã‚«ãƒ¼ãƒ‰
â”‚   â”œâ”€â”€ ServerFilters.tsx       # ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
â”‚   â””â”€â”€ ServerActions.tsx       # ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useServerList.ts        # ã‚µãƒ¼ãƒãƒ¼ä¸€è¦§çŠ¶æ…‹ç®¡ç†
â”‚   â”œâ”€â”€ useServerSearch.ts      # æ¤œç´¢ãƒ­ã‚¸ãƒƒã‚¯
â”‚   â””â”€â”€ useServerActions.ts     # ã‚µãƒ¼ãƒãƒ¼æ“ä½œ
â””â”€â”€ types/
    â””â”€â”€ server-list-types.ts    # ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå›ºæœ‰ã®å‹
```

**`src/components/server/hooks/useServerList.ts`**
```typescript
import { useState, useEffect, useMemo } from 'react';
import { useServerStore } from '../../../lib/stores';
import { useDebounce } from '../../hooks/useDebounce';
import type { MCPServer, ServerStatus } from '../../../lib/types';

interface UseServerListOptions {
  initialSearchTerm?: string;
  initialStatusFilter?: ServerStatus | 'all';
}

export function useServerList(options: UseServerListOptions = {}) {
  const { servers, isLoading, error, refreshServers } = useServerStore();
  
  const [searchTerm, setSearchTerm] = useState(options.initialSearchTerm || '');
  const [statusFilter, setStatusFilter] = useState<ServerStatus | 'all'>(
    options.initialStatusFilter || 'all'
  );
  
  const debouncedSearchTerm = useDebounce(searchTerm, 300);
  
  const filteredServers = useMemo(() => {
    return servers.filter(server => {
      const matchesSearch = !debouncedSearchTerm || 
        server.name.toLowerCase().includes(debouncedSearchTerm.toLowerCase()) ||
        server.description?.toLowerCase().includes(debouncedSearchTerm.toLowerCase());
      
      const matchesStatus = statusFilter === 'all' || server.status === statusFilter;
      
      return matchesSearch && matchesStatus;
    });
  }, [servers, debouncedSearchTerm, statusFilter]);
  
  return {
    // çŠ¶æ…‹
    servers: filteredServers,
    isLoading,
    error,
    searchTerm,
    statusFilter,
    
    // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
    setSearchTerm,
    setStatusFilter,
    refreshServers,
  };
}
```

## æˆåŠŸæŒ‡æ¨™

### ğŸ“Š **Critical Metrics (å“è³ªè©•ä¾¡ã«åŸºã¥ã)**

| æŒ‡æ¨™ | ç¾åœ¨ | ç›®æ¨™ | æ¸¬å®šæ–¹æ³• |
|------|------|------|----------|
| **ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸** | 0% | 80%ä»¥ä¸Š | Vitest coverage |
| **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚³ã‚¢** | 7/10 | 9/10ä»¥ä¸Š | ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ» |
| **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°** | 6/10 | 8/10ä»¥ä¸Š | ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ |
| main.tsã®è¡Œæ•° | 966è¡Œ | 200è¡Œä»¥ä¸‹ | è¡Œæ•°ã‚«ã‚¦ãƒ³ãƒˆ |
| æœ€å¤§ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè¡Œæ•° | 307è¡Œ | 150è¡Œä»¥ä¸‹ | ãƒ•ã‚¡ã‚¤ãƒ«è¡Œæ•°åˆ†æ |

### ğŸ“ˆ **Quality Gates**

#### **Phase 1 å®Œäº†åŸºæº–**
- [ ] ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ 80% ä»¥ä¸Š
- [ ] å…¨ä¸»è¦æ©Ÿèƒ½ã®å˜ä½“ãƒ†ã‚¹ãƒˆå®Œäº†
- [ ] CI/CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å‹•ä½œç¢ºèª

#### **Phase 2 å®Œäº†åŸºæº–**
- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è„†å¼±æ€§ã‚¹ã‚­ãƒ£ãƒ³åˆæ ¼
- [ ] IPCãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ¤œè¨¼ 100% å®Ÿè£…
- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»ãƒ­ã‚°å‹•ä½œç¢ºèª

#### **Phase 3 å®Œäº†åŸºæº–**
- [ ] çµ±ä¸€ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚° 100% é©ç”¨
- [ ] æ§‹é€ åŒ–ãƒ­ã‚°å…¨ä½“é©ç”¨
- [ ] ã‚¨ãƒ©ãƒ¼è¿½è·¡ã‚·ã‚¹ãƒ†ãƒ å‹•ä½œç¢ºèª

## ãƒªã‚¹ã‚¯ç®¡ç†

### ğŸš¨ **Critical Risks**

1. **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è„†å¼±æ€§ã®è¦‹è½ã¨ã—**
   - **å¯¾ç­–**: æ®µéšçš„ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»ã¨ãƒšãƒãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆ
   - **å›é¿ç­–**: å¤–éƒ¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å°‚é–€å®¶ã«ã‚ˆã‚‹ãƒ¬ãƒ“ãƒ¥ãƒ¼

2. **ãƒ†ã‚¹ãƒˆå®Ÿè£…ã®é…å»¶**
   - **å¯¾ç­–**: ä¸¦è¡Œé–‹ç™ºã¨ãƒšã‚¢ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°
   - **å›é¿ç­–**: æœ€é‡è¦æ©Ÿèƒ½ã®å„ªå…ˆå®Ÿè£…

3. **æ—¢å­˜æ©Ÿèƒ½ã®ç ´ç¶»**
   - **å¯¾ç­–**: å„æ®µéšã§ã®ç¶™ç¶šçš„çµ±åˆãƒ†ã‚¹ãƒˆ
   - **å›é¿ç­–**: æ©Ÿèƒ½ãƒ•ãƒ©ã‚°ã«ã‚ˆã‚‹æ®µéšçš„åˆ‡ã‚Šæ›¿ãˆ

### ğŸ›¡ **Mitigation Strategies**

1. **å“è³ªä¿è¨¼ãƒ—ãƒ­ã‚»ã‚¹**
   - ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼å¿…é ˆ (2åä»¥ä¸Š)
   - è‡ªå‹•ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ (PRæ™‚)
   - ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³ (æ—¥æ¬¡)

2. **ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯è¨ˆç”»**
   - å„ãƒ•ã‚§ãƒ¼ã‚ºã§ã®ã‚¿ã‚°ä½œæˆ
   - ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°
   - è¨­å®šã®å¾Œæ–¹äº’æ›æ€§ç¶­æŒ

---

## ğŸ“ ã¾ã¨ã‚

### ğŸš¨ **Critical Path ã®é‡è¦æ€§**

ã“ã®æ›´æ–°ã•ã‚ŒãŸãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°è¨ˆç”»ã¯ã€**å“è³ªè©•ä¾¡çµæœã«åŸºã¥ã Critical Issues ã¸ã®å¯¾å¿œ**ã‚’æœ€å„ªå…ˆã«è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ã€‚

### ğŸ¯ **é‡è¦ãªå¤‰æ›´ç‚¹**

1. **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆ**: å…¥åŠ›æ¤œè¨¼ã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–ã‚’æœ€å„ªå…ˆ
2. **ãƒ†ã‚¹ãƒˆä¸»å°**: å“è³ªä¿è¨¼ã‚’åŸºç›¤ã¨ã—ãŸé–‹ç™ºãƒ—ãƒ­ã‚»ã‚¹
3. **æ®µéšçš„æ”¹å–„**: æ—¢å­˜ã®è‰¯å¥½ãªã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚’æ´»ç”¨
4. **ç¾å®Ÿçš„ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«**: 7é€±é–“ã§å®Ÿè¡Œå¯èƒ½ãªè¨ˆç”»

### ğŸ’¡ **æœŸå¾…ã•ã‚Œã‚‹åŠ¹æœ**

- **çŸ­æœŸ**: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è„†å¼±æ€§ã®è§£æ¶ˆã¨åŸºæœ¬çš„å“è³ªä¿è¨¼
- **ä¸­æœŸ**: åŒ…æ‹¬çš„ãªãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ã¨é–‹ç™ºåŠ¹ç‡å‘ä¸Š
- **é•·æœŸ**: æŒç¶šå¯èƒ½ã§æ‹¡å¼µæ€§ã®é«˜ã„ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³åŸºç›¤

ã“ã®è¨ˆç”»ã«ã‚ˆã‚Šã€MCP Routerã¯**æœ¬ç•ªç’°å¢ƒã«é©ã—ãŸé«˜å“è³ªãªã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³**ã¸ã¨ç¢ºå®Ÿã«é€²åŒ–ã—ã¾ã™ã€‚